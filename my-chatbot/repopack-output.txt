================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2025-01-14T05:05:00.937Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
api/
  chat.js
  test_bot.py
  test_env.py
public/
  vite.svg
scripts/
  rso_bot.py
src/
  assets/
    react.svg
  App.css
  App.jsx
  ChatGPTInterface.jsx
  index.css
  main.jsx
.gitignore
eslint.config.js
index.html
package.json
portDiscovery.js
postcss.config.js
README.md
server.js
tailwind.config.js
vite.config.js

================================================================
Repository Files
================================================================

================
File: api/chat.js
================
// api/chat.js
import { PythonShell } from 'python-shell';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const TIMEOUT = 60000; // Increased to 60 seconds

const chatHandler = async (req) => {
    console.log('\n========== CHAT REQUEST STARTED ==========');
    console.log('Timestamp:', new Date().toISOString());
    console.log('Request payload:', req);
    
    try {
        if (!req.message) {
            console.log('Error: Message is missing from request');
            throw new Error('Message is required');
        }

        const scriptPath = path.join(__dirname, '..', 'scripts', 'rso_bot.py');
        console.log('Python script path:', scriptPath);
        
        // Check if the script exists
        try {
            await import('fs').then(fs => fs.promises.access(scriptPath));
            console.log('Python script found at path');
        } catch (error) {
            console.error('Python script not found:', error);
            throw new Error('Python script not found at ' + scriptPath);
        }
        
        const options = {
            mode: 'json',
            pythonPath: 'python3',
            pythonOptions: ['-u'], // unbuffered output
            scriptPath: path.dirname(scriptPath),
            args: [req.message],
            env: {
                ...process.env,
                PYTHONUNBUFFERED: '1'
            }
        };

        console.log('Starting Python script with options:', {
            scriptPath: options.scriptPath,
            pythonPath: options.pythonPath,
            message: req.message
        });

        const runPythonScript = () => {
            console.log('Executing Python script...');
            return new Promise((resolve, reject) => {
                let hasResponded = false;
                let outputBuffer = [];
                
                const timeoutId = setTimeout(() => {
                    if (!hasResponded) {
                        hasResponded = true;
                        console.error('Python script execution timed out');
                        console.error('Collected output:', outputBuffer.join('\n'));
                        reject(new Error(`Python script execution timed out after ${TIMEOUT/1000} seconds`));
                    }
                }, TIMEOUT);

                const pyshell = new PythonShell(path.basename(scriptPath), options);

                pyshell.on('message', (message) => {
                    console.log('Python output:', message);
                    outputBuffer.push(message);
                });

                pyshell.on('stderr', (stderr) => {
                    console.error('Python stderr:', stderr);
                    outputBuffer.push(`ERROR: ${stderr}`);
                });

                pyshell.end((err, code, signal) => {
                    clearTimeout(timeoutId);

                    if (hasResponded) return;
                    hasResponded = true;

                    if (err) {
                        console.error('Python script error:', err);
                        console.error('Exit code:', code);
                        console.error('Signal:', signal);
                        console.error('Collected output:', outputBuffer.join('\n'));
                        reject(err);
                        return;
                    }

                    const lastOutput = outputBuffer[outputBuffer.length - 1];
                    try {
                        const result = typeof lastOutput === 'string' ? JSON.parse(lastOutput) : lastOutput;
                        if (result.error) {
                            reject(new Error(result.error));
                        } else {
                            resolve(result.response);
                        }
                    } catch (e) {
                        reject(new Error('Invalid response format from Python script'));
                    }
                });
            });
        };

        console.log('Awaiting Python script execution...');
        const response = await runPythonScript();
        console.log('Python script execution completed successfully');
        console.log('Response:', response);
        console.log('========== CHAT REQUEST COMPLETED ==========\n');
        return { response };
        
    } catch (error) {
        console.error('========== CHAT REQUEST FAILED ==========');
        console.error('Error details:', error);
        console.error('Stack trace:', error.stack);
        console.error('==========================================\n');
        throw error;
    }
};

export default chatHandler;

================
File: api/test_bot.py
================
#!/usr/bin/env python3
# api/test_bot.py
from rso_bot import RSORagBot
import os
from dotenv import load_dotenv
import logging
from pathlib import Path

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_bot():
    try:
        # Get the directory containing this script
        script_dir = Path(__file__).parent.absolute()
        # Look for .env in the parent directory (project root)
        env_path = script_dir.parent / '.env'
        
        # Load environment variables from the correct path
        load_dotenv(dotenv_path=env_path)
        logger.info(f"Looking for .env file at: {env_path}")
        
        # Check environment variables
        pinecone_key = os.getenv('PINECONE_API_KEY')
        groq_key = os.getenv('GROQ_API_KEY')
        
        if not pinecone_key or not groq_key:
            print("Error: Missing API keys")
            print(f"Searched for .env file at: {env_path}")
            return
            
        print("Initializing bot...")
        bot = RSORagBot(
            pinecone_api_key=pinecone_key,
            pinecone_index_name="rso-chatbot",
            groq_api_key=groq_key
        )
        
        # Test query
        test_query = "I'm interested in computer science clubs"
        print(f"\nTesting with query: {test_query}")
        
        print("\nGetting response...")
        response = bot.generate_response(test_query)
        
        print("\nResponse received:")
        print(response)
        
    except Exception as e:
        print(f"Error during test: {str(e)}")

if __name__ == "__main__":
    test_bot()

================
File: api/test_env.py
================
#!/usr/bin/env python3
# api/test_env.py
import os
from dotenv import load_dotenv

def test_environment():
    load_dotenv()
    
    # Check for required environment variables
    required_vars = {
        "PINECONE_API_KEY": os.getenv("PINECONE_API_KEY"),
        "GROQ_API_KEY": os.getenv("GROQ_API_KEY")
    }
    
    print("Environment Variables Check:")
    for var_name, value in required_vars.items():
        if value:
            print(f"✓ {var_name} is set")
            print(f"  Length: {len(value)} characters")
        else:
            print(f"✗ {var_name} is NOT set")
    
    # Test Python packages
    print("\nPython Packages Check:")
    packages = ["pinecone", "sentence_transformers", "groq", "dotenv"]
    
    for package in packages:
        try:
            __import__(package)
            print(f"✓ {package} is installed")
        except ImportError as e:
            print(f"✗ {package} is NOT installed: {str(e)}")

if __name__ == "__main__":
    test_environment()

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: scripts/rso_bot.py
================
#!/usr/bin/env python3
import pinecone
from sentence_transformers import SentenceTransformer
from groq import Groq
import os
from dotenv import load_dotenv
import sys
import json
import logging
from pathlib import Path
import time
from typing import List, Dict, Optional, Any, Union

# Set up logging with more detailed format
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    stream=sys.stderr
)
logger = logging.getLogger(__name__)

# Get the directory containing this script
script_dir = Path(__file__).parent.absolute()
env_path = script_dir.parent / '.env'

# Load environment variables
load_dotenv(dotenv_path=env_path)

# Global bot instance
_bot_instance = None

class RSORagBot:
    def __init__(self, pinecone_api_key: Optional[str] = None, 
                 pinecone_index_name: Optional[str] = None, 
                 groq_api_key: Optional[str] = None):
        """
        Initialize the RSO bot with API keys and necessary clients
        """
        try:
            # Get API keys from parameters or environment
            self.pinecone_api_key = pinecone_api_key or os.getenv('PINECONE_API_KEY')
            self.groq_api_key = groq_api_key or os.getenv('GROQ_API_KEY')
            self.pinecone_index_name = pinecone_index_name or os.getenv('PINECONE_INDEX_NAME', 'rso-chatbot')

            if not self.pinecone_api_key:
                raise ValueError("Pinecone API key not found")
            if not self.groq_api_key:
                raise ValueError("Groq API key not found")

            # Initialize Pinecone
            self.pc = pinecone.Pinecone(api_key=self.pinecone_api_key)
            self.index = self.pc.Index(self.pinecone_index_name)
            
            # Initialize embedding model
            self.embed_model = SentenceTransformer('all-mpnet-base-v2')
            
            # Initialize Groq client
            self.groq_client = Groq(api_key=self.groq_api_key)
            
            # Define system prompt
            self.system_prompt = """You are a knowledgeable and helpful assistant for University of Chicago students, 
            specializing in Registered Student Organizations (RSOs). Your role is to help students learn about and 
            engage with RSOs by:

            - Providing accurate, detailed information about specific RSOs when asked
            - Recommending relevant RSOs based on students' interests and preferences
            - Explaining RSO activities, events, and opportunities
            - Helping with general RSO-related questions
            - Clarifying any confusion about RSOs or the membership process

            Focus on addressing the student's specific question while maintaining a helpful and informative tone.
            If you're not sure about specific details, be honest about what you don't know."""

        except Exception as e:
            logger.error(f"Initialization error: {str(e)}", exc_info=True)
            raise

    def get_relevant_rsos(self, query: str, top_k: int = 3) -> List[Dict[str, Any]]:
        """
        Get relevant RSOs based on the query
        
        Args:
            query: The search query
            top_k: Number of results to return
            
        Returns:
            List of matching RSOs with their metadata
        """
        try:
            logger.info(f"Searching for RSOs with query: {query}")
            query_embedding = self.embed_model.encode(query).tolist()
            
            results = self.index.query(
                vector=query_embedding,
                top_k=top_k,
                include_metadata=True
            )
            
            logger.info(f"Found {len(results.matches)} matching RSOs")
            return results.matches
            
        except Exception as e:
            logger.error(f"Error in get_relevant_rsos: {str(e)}", exc_info=True)
            return []

    def format_context(self, relevant_rsos: List[Dict[str, Any]]) -> str:
        """
        Format RSO information into a context string for the LLM
        
        Args:
            relevant_rsos: List of RSO matches with metadata
            
        Returns:
            Formatted context string
        """
        try:
            if not relevant_rsos:
                return "No relevant RSOs found in the database."
            
            context = "Here is the RSO information:\n\n"
            
            for rso in relevant_rsos:
                metadata = rso.metadata
                try:
                    # Required fields
                    context += f"Name: {metadata.get('name', 'N/A')}\n"
                    context += f"Description: {metadata.get('description', 'N/A')}\n"
                    
                    # Optional fields with validation
                    categories = metadata.get('categories', [])
                    if categories and isinstance(categories, list):
                        context += f"Categories: {', '.join(categories)}\n"
                    
                    contact = metadata.get('contact_email')
                    if contact and contact.lower() not in ['none', 'n/a', '']:
                        context += f"Contact: {contact}\n"
                    
                    social_media = metadata.get('social_media_links', [])
                    if social_media and isinstance(social_media, list):
                        context += f"Social Media: {', '.join(social_media)}\n"
                    
                    additional_info = metadata.get('additional_info', [])
                    if additional_info and isinstance(additional_info, list):
                        context += f"Additional Info: {', '.join(additional_info)}\n"
                    
                    website = metadata.get('full_url')
                    if website and website.lower() not in ['none', 'n/a', '']:
                        context += f"Website: {website}\n"
                    
                    context += "\n"
                    
                except Exception as e:
                    logger.error(f"Error formatting RSO metadata: {str(e)}", exc_info=True)
                    continue
            
            return context
            
        except Exception as e:
            logger.error(f"Error in format_context: {str(e)}", exc_info=True)
            return "Error formatting RSO information."

    def generate_response(self, query: str) -> str:
        """
        Generate a response based on the query and relevant RSO information
        
        Args:
            query: The user's question or request
            
        Returns:
            Generated response string
        """
        try:
            # Normalize query
            normalized_query = query.lower().replace('club', 'rso')
            logger.info(f"Original query: {query}")
            logger.info(f"Normalized query: {normalized_query}")

            # Get relevant RSOs
            relevant_rsos = self.get_relevant_rsos(normalized_query)
            
            # Format context
            context = self.format_context(relevant_rsos)
            
            # Construct prompt
            prompt = f"""Here is a student's question about UChicago RSOs: "{query}"

            Based on the query, here are relevant RSOs from our database:

            {context}

            Please provide a natural, conversational response that:
            1. Directly addresses their specific question or need
            2. Only mentions RSOs that are truly relevant to their query
            3. Provides specific, actionable information when available
            4. Acknowledges if the available information might not fully answer their question

            If their question isn't about finding RSOs, focus on answering their question rather than listing RSOs."""
            
            # Get response from Groq
            response = self.groq_client.chat.completions.create(
                messages=[
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": prompt}
                ],
                model="mixtral-8x7b-32768",
                temperature=0.7,
                max_tokens=1024
            )
            
            return response.choices[0].message.content
            
        except Exception as e:
            logger.error(f"Error in generate_response: {str(e)}", exc_info=True)
            return f"I apologize, but I encountered an error while processing your question. Please try asking again or rephrase your question."

def get_bot_instance() -> RSORagBot:
    """Get or create a singleton instance of RSORagBot"""
    global _bot_instance
    if _bot_instance is None:
        try:
            logger.info("Creating new RSORagBot instance")
            _bot_instance = RSORagBot()
            logger.info("RSORagBot instance created successfully")
        except Exception as e:
            logger.error(f"Error creating RSORagBot instance: {str(e)}", exc_info=True)
            raise
    return _bot_instance

def main() -> None:
    """Main function to handle command line queries"""
    try:
        if len(sys.argv) < 2:
            error_msg = {"error": "No query provided"}
            logger.error("No query provided")
            print(json.dumps(error_msg))
            return

        query = sys.argv[1]
        logger.info(f"Processing query: {query}")
        
        # Get or create bot instance
        bot = get_bot_instance()
        
        # Generate response
        start_time = time.time()
        response = bot.generate_response(query)
        total_time = time.time() - start_time
        
        logger.info(f"Total processing time: {total_time:.2f} seconds")
        print(json.dumps({"response": response}))
        
    except Exception as e:
        logger.error(f"Error in main: {str(e)}", exc_info=True)
        print(json.dumps({"error": str(e)}))

if __name__ == "__main__":
    main()

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/App.css
================
/* Reset default styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Main app container */
.app-container {
  height: 100vh;
  width: 100vw;
  overflow: hidden;
}

/* Custom scrollbar for webkit browsers */
::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #666;
}

/* Textarea auto-resize */
textarea {
  min-height: 44px;
  max-height: 200px;
  resize: none;
  overflow-y: auto;
}

/* Message transitions */
.message-enter {
  opacity: 0;
  transform: translateY(20px);
}

.message-enter-active {
  opacity: 1;
  transform: translateY(0);
  transition: opacity 300ms, transform 300ms;
}

/* Dark mode overrides */
@media (prefers-color-scheme: dark) {
  body {
    background-color: #343541;
    color: #FFFFFF;
  }
  
  .dark-mode {
    background-color: #343541;
  }
  
  .dark-mode .message-bubble {
    background-color: #444654;
  }
  
  .dark-mode .user-message {
    background-color: #343541;
  }
  
  .dark-mode textarea {
    background-color: #40414F;
    color: #FFFFFF;
    border-color: #565869;
  }
  
  .dark-mode .sidebar {
    background-color: #202123;
  }
}

================
File: src/App.jsx
================
import React from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import ChatInterface from './ChatGPTInterface'

const queryClient = new QueryClient()

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <div className="h-screen">
        <ChatInterface />
      </div>
    </QueryClientProvider>
  )
}

export default App

================
File: src/ChatGPTInterface.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';

const ChatInterface = () => {
  const [chats, setChats] = useState([]);
  const [currentChat, setCurrentChat] = useState(null);
  const [message, setMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [backendUrl, setBackendUrl] = useState(null);
  const [connectionError, setConnectionError] = useState(false);
  const [discoveryAttempts, setDiscoveryAttempts] = useState(0);
  const messagesEndRef = useRef(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [currentChat?.messages]);

  useEffect(() => {
    const discoverBackendPort = async () => {
      try {
        const startPort = 3003;
        const maxPort = startPort + 20;
        let connected = false;

        console.log('Starting backend discovery...');

        for (let port = startPort; port <= maxPort; port++) {
          try {
            console.log(`Trying port ${port}...`);
            const response = await axios.get(`http://localhost:${port}/api/port`, {
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
              },
              withCredentials: true,
              timeout: 1000 // 1 second timeout for each attempt
            });

            if (response.data && response.data.port) {
              const url = `http://localhost:${response.data.port}`;
              console.log(`Successfully connected to backend at ${url}`);
              setBackendUrl(url);
              setConnectionError(false);
              connected = true;
              break;
            }
          } catch (e) {
            console.log(`Port ${port} not available:`, e.message);
          }
        }

        if (!connected) {
          console.error('Could not connect to any backend port');
          setConnectionError(true);
          if (discoveryAttempts < 3) {
            setTimeout(() => {
              setDiscoveryAttempts(prev => prev + 1);
            }, 2000);
          }
        }
      } catch (error) {
        console.error('Backend discovery failed:', error);
        setConnectionError(true);
        if (discoveryAttempts < 3) {
          setTimeout(() => {
            setDiscoveryAttempts(prev => prev + 1);
          }, 2000);
        }
      }
    };

    discoverBackendPort();
  }, [discoveryAttempts]);

  const createChat = () => {
    const newChat = {
      id: Date.now(),
      title: `Chat ${chats.length + 1}`,
      messages: []
    };
    setChats(prevChats => [...prevChats, newChat]);
    setCurrentChat(newChat);
    console.log('Created new chat:', newChat);
  };

  const deleteChat = (chatId) => {
    setChats(prevChats => prevChats.filter(chat => chat.id !== chatId));
    if (currentChat?.id === chatId) {
      setCurrentChat(null);
    }
    console.log('Deleted chat:', chatId);
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    
    console.log('Send attempt:', {
      hasMessage: Boolean(message.trim()),
      hasCurrentChat: Boolean(currentChat),
      hasBackendUrl: Boolean(backendUrl),
      message,
      currentChatId: currentChat?.id
    });

    if (!message.trim() || !currentChat || !backendUrl) {
      console.log('Send conditions not met');
      return;
    }

    const updatedChat = {
      ...currentChat,
      messages: [...currentChat.messages, { role: 'user', content: message }]
    };
    
    setChats(prevChats => 
      prevChats.map(chat => chat.id === currentChat.id ? updatedChat : chat)
    );
    setCurrentChat(updatedChat);
    
    const userMessage = message;
    setMessage('');
    setIsLoading(true);

    try {
      console.log('Sending message to:', `${backendUrl}/api/chat`);
      
      const response = await axios.post(`${backendUrl}/api/chat`, 
        {
          message: userMessage,
          chatId: currentChat.id
        }, 
        {
          headers: {
            'Content-Type': 'application/json'
          },
          withCredentials: true
        }
      );

      console.log('Received response:', response.data);

      if (response.data && response.data.response) {
        const updatedChatWithResponse = {
          ...updatedChat,
          messages: [...updatedChat.messages, { 
            role: 'assistant', 
            content: response.data.response 
          }]
        };
        setChats(prevChats => 
          prevChats.map(chat => chat.id === currentChat.id ? updatedChatWithResponse : chat)
        );
        setCurrentChat(updatedChatWithResponse);
      } else {
        throw new Error('Invalid response format from server');
      }
    } catch (error) {
      console.error('Error details:', {
        message: error.message,
        response: error.response?.data,
        status: error.response?.status
      });

      const errorMessage = error.response?.data?.error || error.message || 'Failed to send message';
      const updatedChatWithError = {
        ...updatedChat,
        messages: [...updatedChat.messages, 
          { role: 'system', content: `Error: ${errorMessage}`, isError: true }
        ]
      };
      setChats(prevChats => 
        prevChats.map(chat => chat.id === currentChat.id ? updatedChatWithError : chat)
      );
      setCurrentChat(updatedChatWithError);
    } finally {
      setIsLoading(false);
    }
  };

  if (connectionError) {
    return (
      <div className="flex h-screen items-center justify-center bg-gray-100">
        <div className="text-center p-4 bg-white rounded shadow">
          <h2 className="text-xl text-red-600 mb-2">Connection Error</h2>
          <p className="mb-2">Unable to connect to the backend server.</p>
          <p className="text-sm text-gray-600 mb-4">
            Make sure the backend server is running and try again.
          </p>
          <button 
            onClick={() => setDiscoveryAttempts(prev => prev + 1)} 
            className="mt-4 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
          >
            Retry Connection ({3 - discoveryAttempts} attempts remaining)
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex h-screen bg-gray-100">
      {/* Debug info */}
      {process.env.NODE_ENV === 'development' && (
        <div className="fixed top-0 right-0 bg-black text-white p-2 text-xs">
          Backend: {backendUrl || 'Not connected'}
        </div>
      )}

      {/* Sidebar */}
      <div className="w-64 bg-white p-4 border-r">
        <button
          onClick={createChat}
          className="w-full bg-blue-500 text-white p-2 rounded mb-4 hover:bg-blue-600"
        >
          New Chat
        </button>
        <div className="space-y-2 overflow-y-auto max-h-[calc(100vh-6rem)]">
          {chats.map(chat => (
            <div
              key={chat.id}
              className="flex justify-between items-center p-2 hover:bg-gray-100 rounded cursor-pointer"
              onClick={() => setCurrentChat(chat)}
            >
              <span className={`text-black ${currentChat?.id === chat.id ? 'font-bold' : ''}`}>
                {chat.title}
              </span>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  deleteChat(chat.id);
                }}
                className="text-red-500 hover:text-red-700"
              >
                Delete
              </button>
            </div>
          ))}
        </div>
      </div>

      {/* Chat Area */}
      <div className="flex-1 flex flex-col">
        {currentChat ? (
          <>
            {/* Messages */}
            <div className="flex-1 p-4 overflow-y-auto bg-white">
              {currentChat.messages.map((msg, index) => (
                <div
                  key={index}
                  className={`mb-4 ${msg.role === 'user' ? 'text-right' : 'text-left'}`}
                >
                  <div
                    className={`inline-block p-2 rounded-lg max-w-[70%] ${
                      msg.role === 'user'
                        ? 'bg-blue-500 text-white'
                        : msg.isError
                        ? 'bg-red-100 text-red-600'
                        : 'bg-gray-200 text-black'
                    }`}
                  >
                    {msg.content}
                  </div>
                </div>
              ))}
              {isLoading && (
                <div className="text-center text-gray-500">
                  AI is thinking...
                </div>
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* Input Area */}
            <div className="p-4 border-t bg-white">
              <form onSubmit={handleSendMessage} className="flex space-x-4">
                <input
                  type="text"
                  value={message}
                  onChange={(e) => setMessage(e.target.value)}
                  className="flex-1 p-2 border rounded text-black"
                  placeholder="Type your message..."
                />
                <button
                  type="submit"
                  disabled={isLoading || !backendUrl || !currentChat}
                  className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 disabled:bg-blue-300"
                >
                  {isLoading ? 'Sending...' : 'Send'}
                </button>
              </form>
            </div>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center text-gray-500">
            Select or create a chat to start messaging
          </div>
        )}
      </div>
    </div>
  );
};

export default ChatInterface;

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary-color: #2563eb;
  --background-dark: #343541;
  --sidebar-dark: #202123;
  --message-dark: #444654;
  --input-dark: #40414F;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: var(--background-dark);
  color: #fff;
}

html, body, #root {
  height: 100%;
  overflow: hidden;
}

::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #666;
}

================
File: src/main.jsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App'

createRoot(document.getElementById('root')).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.env

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "my-chatbot",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "server": "node server.js",
    "dev:all": "concurrently \"npm run dev\" \"npm run server\""
  },
  "dependencies": {
    "@tanstack/react-query": "^5.64.0",
    "axios": "^1.7.9",
    "cors": "^2.8.5",
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "groq": "^3.69.0",
    "lucide-react": "^0.469.0",
    "node-fetch": "^3.3.2",
    "openai": "^4.78.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "python-shell": "^5.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.17.0",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@vitejs/plugin-react": "^4.3.4",
    "autoprefixer": "^10.4.20",
    "concurrently": "^8.2.2",
    "eslint": "^9.17.0",
    "eslint-plugin-react": "^7.37.2",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.16",
    "globals": "^15.14.0",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.17",
    "vite": "^6.0.5"
  }
}

================
File: portDiscovery.js
================
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const PORT_FILE = path.join(__dirname, 'port.txt');

export const savePort = async (port) => {
  try {
    await fs.writeFile(PORT_FILE, port.toString());
    console.log(`Port ${port} saved to ${PORT_FILE}`);
  } catch (error) {
    console.error('Error saving port:', error);
  }
};

================
File: postcss.config.js
================
export default {
    plugins: {
      tailwindcss: {},
      autoprefixer: {},
    },
  }

================
File: README.md
================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

================
File: server.js
================
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import net from 'net';
import chatHandler from './api/chat.js';

dotenv.config();

const app = express();

// Utility function to check if a port is available
const isPortAvailable = (port) => {
  return new Promise((resolve) => {
    const server = net.createServer()
      .once('error', () => {
        resolve(false);
      })
      .once('listening', () => {
        server.close();
        resolve(true);
      })
      .listen(port);
  });
};

// Find an available port
const findAvailablePort = async (startPort) => {
  let port = startPort;
  while (!(await isPortAvailable(port))) {
    console.log(`Port ${port} is in use, trying next port...`);
    port++;
  }
  return port;
};

// Dynamic CORS configuration
const corsOptions = {
  origin: function (origin, callback) {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    
    // Check if the origin matches our pattern
    const allowedOrigins = Array.from({ length: 20 }, (_, i) => i + 5173)
      .flatMap(port => [`http://localhost:${port}`, `http://127.0.0.1:${port}`]);
    
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      console.log(`Origin ${origin} not allowed by CORS`);
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
};

app.use(cors(corsOptions));
app.options('*', cors(corsOptions));

app.use(express.json());

// Enhanced logging middleware with timing
app.use((req, res, next) => {
  const start = Date.now();
  const timestamp = new Date().toISOString();
  const requestId = Math.random().toString(36).substring(7);

  console.log(`\n=== Request ${requestId} Started ===`);
  console.log(`Time: ${timestamp}`);
  console.log(`${req.method} ${req.path}`);
  console.log('Headers:', JSON.stringify(req.headers, null, 2));
  
  if (req.body && Object.keys(req.body).length > 0) {
    console.log('Body:', JSON.stringify(req.body, null, 2));
  }

  // Capture response
  const oldSend = res.send;
  res.send = function(data) {
    const duration = Date.now() - start;
    console.log(`\n=== Request ${requestId} Completed ===`);
    console.log(`Duration: ${duration}ms`);
    console.log('Response:', typeof data === 'string' ? data : JSON.stringify(data, null, 2));
    console.log('===============================\n');
    oldSend.apply(res, arguments);
  };

  next();
});

// Enhanced port discovery endpoint
app.get('/api/port', (req, res) => {
  const port = app.get('port');
  console.log('Port discovery request received:');
  console.log('- Port:', port);
  console.log('- Origin:', req.headers.origin);
  res.json({ 
    port: port, 
    status: 'active',
    serverTime: new Date().toISOString()
  });
});

// Enhanced chat endpoint with timeout
app.post('/api/chat', async (req, res) => {
  const requestId = Math.random().toString(36).substring(7);
  console.log(`\n=== Chat Request ${requestId} ===`);
  console.log('Time:', new Date().toISOString());
  console.log('Body:', req.body);

  const TIMEOUT = 30000; // 30 second timeout

  try {
    if (!req.body.message) {
      throw new Error('Message is required');
    }

    // Create a timeout promise
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Request timeout after 30 seconds')), TIMEOUT);
    });

    // Race between the chat handler and the timeout
    const result = await Promise.race([
      chatHandler(req.body),
      timeoutPromise
    ]);

    console.log(`Chat Request ${requestId} completed successfully`);
    console.log('Response:', result);
    res.json(result);

  } catch (error) {
    console.error(`Error in chat request ${requestId}:`, error);
    const errorResponse = {
      error: error.message,
      type: error.name,
      requestId: requestId
    };

    // Add stack trace in development
    if (process.env.NODE_ENV === 'development') {
      errorResponse.stack = error.stack;
    }

    res.status(500).json(errorResponse);
  }
});

// Add a health check endpoint
app.get('/api/health', (req, res) => {
  res.json({
    status: 'healthy',
    time: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({
    error: 'Internal server error',
    message: err.message,
    ...(process.env.NODE_ENV === 'development' && { stack: err.stack })
  });
});

// Server startup with enhanced error handling
const startServer = async () => {
  const preferredPort = 3003;
  try {
    const port = await findAvailablePort(preferredPort);
    app.set('port', port);
    
    const server = app.listen(port, () => {
      console.log('\n=== Server Started ===');
      console.log(`Time: ${new Date().toISOString()}`);
      console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
      console.log(`Port: ${port}`);
      console.log('\nAvailable endpoints:');
      console.log(`- GET  http://localhost:${port}/api/port    (Port discovery)`);
      console.log(`- POST http://localhost:${port}/api/chat    (Chat endpoint)`);
      console.log(`- GET  http://localhost:${port}/api/health  (Health check)`);
      console.log('\nPress Ctrl+C to stop the server');
      console.log('=====================\n');
    });

    // Graceful shutdown handling
    process.on('SIGTERM', () => {
      console.log('SIGTERM received. Shutting down gracefully...');
      server.close(() => {
        console.log('Server closed');
        process.exit(0);
      });
    });

  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

// Global error handlers
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

startServer();

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
export default {
    content: [
      "./index.html",
      "./src/**/*.{js,ts,jsx,tsx}",
    ],
    theme: {
      extend: {},
    },
    plugins: [],
  }

================
File: vite.config.js
================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:3003',
        changeOrigin: true,
        secure: false,
        ws: true,
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('Sending Request to the Target:', req.method, req.url);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('Received Response from the Target:', proxyRes.statusCode, req.url);
          });
        },
      },
    },
  },
});
